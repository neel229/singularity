// Code generated by sqlc. DO NOT EDIT.
// source: trade.sql

package db

import (
	"context"
)

const createTrade = `-- name: CreateTrade :one
INSERT INTO trade (
    stock_id,
    buyer_id,
    seller_id,
    quantity,
    unit_price,
    details,
    offer_id
  )
VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, stock_id, buyer_id, seller_id, quantity, unit_price, details, offer_id
`

type CreateTradeParams struct {
	StockID   int64  `json:"stock_id"`
	BuyerID   int64  `json:"buyer_id"`
	SellerID  int64  `json:"seller_id"`
	Quantity  string `json:"quantity"`
	UnitPrice string `json:"unit_price"`
	Details   string `json:"details"`
	OfferID   int64  `json:"offer_id"`
}

func (q *Queries) CreateTrade(ctx context.Context, arg CreateTradeParams) (Trade, error) {
	row := q.db.QueryRowContext(ctx, createTrade,
		arg.StockID,
		arg.BuyerID,
		arg.SellerID,
		arg.Quantity,
		arg.UnitPrice,
		arg.Details,
		arg.OfferID,
	)
	var i Trade
	err := row.Scan(
		&i.ID,
		&i.StockID,
		&i.BuyerID,
		&i.SellerID,
		&i.Quantity,
		&i.UnitPrice,
		&i.Details,
		&i.OfferID,
	)
	return i, err
}

const getTrade = `-- name: GetTrade :one
SELECT id, stock_id, buyer_id, seller_id, quantity, unit_price, details, offer_id
FROM trade
WHERE id = $1
LIMIT 1
`

func (q *Queries) GetTrade(ctx context.Context, id int64) (Trade, error) {
	row := q.db.QueryRowContext(ctx, getTrade, id)
	var i Trade
	err := row.Scan(
		&i.ID,
		&i.StockID,
		&i.BuyerID,
		&i.SellerID,
		&i.Quantity,
		&i.UnitPrice,
		&i.Details,
		&i.OfferID,
	)
	return i, err
}

const getTradesByBuyer = `-- name: GetTradesByBuyer :many
SELECT id, stock_id, buyer_id, seller_id, quantity, unit_price, details, offer_id
FROM trade
WHERE buyer_id = $1
ORDER BY id
LIMIT $2 OFFSET $3
`

type GetTradesByBuyerParams struct {
	BuyerID int64 `json:"buyer_id"`
	Limit   int32 `json:"limit"`
	Offset  int32 `json:"offset"`
}

func (q *Queries) GetTradesByBuyer(ctx context.Context, arg GetTradesByBuyerParams) ([]Trade, error) {
	rows, err := q.db.QueryContext(ctx, getTradesByBuyer, arg.BuyerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Trade
	for rows.Next() {
		var i Trade
		if err := rows.Scan(
			&i.ID,
			&i.StockID,
			&i.BuyerID,
			&i.SellerID,
			&i.Quantity,
			&i.UnitPrice,
			&i.Details,
			&i.OfferID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTradesBySeller = `-- name: GetTradesBySeller :many
SELECT id, stock_id, buyer_id, seller_id, quantity, unit_price, details, offer_id
FROM trade
WHERE seller_id = $1
ORDER BY id
LIMIT $2 OFFSET $3
`

type GetTradesBySellerParams struct {
	SellerID int64 `json:"seller_id"`
	Limit    int32 `json:"limit"`
	Offset   int32 `json:"offset"`
}

func (q *Queries) GetTradesBySeller(ctx context.Context, arg GetTradesBySellerParams) ([]Trade, error) {
	rows, err := q.db.QueryContext(ctx, getTradesBySeller, arg.SellerID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Trade
	for rows.Next() {
		var i Trade
		if err := rows.Scan(
			&i.ID,
			&i.StockID,
			&i.BuyerID,
			&i.SellerID,
			&i.Quantity,
			&i.UnitPrice,
			&i.Details,
			&i.OfferID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
